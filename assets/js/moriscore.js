// Generated by CoffeeScript 1.7.1
(function() {
  var arg_first, coll_last, dont_chain, end_of_chain, exports, m_, previousDef, previousDef$, result, root,
    __slice = [].slice;

  root = this;

  previousDef = root.m_;

  previousDef$ = root.m$;

  m_ = function(obj) {
    if (obj instanceof m_) {
      return obj;
    } else if (!(this instanceof m_)) {
      return new m_(obj);
    } else {
      this._wrapped = mori.is_collection(obj) ? obj : mori.js_to_clj(obj);
    }
  };

  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = m_;
    } else {
      exports.m_ = m_;
    }
  } else {
    root.m_ = m_;
  }

  m_.noConflict = function() {
    root.m_ = previousDef;
    root.m$ = previousDef$;
    return m_;
  };

  m_.prototype.to_js = function() {
    return mori.clj_to_js(this._wrapped);
  };

  m_.chain = function(obj) {
    return m_(obj).chain();
  };

  root.m$ = m_.chain;

  m_.prototype.chain = function() {
    this._chain = true;
    return this;
  };

  m_.prototype.value = function() {
    return this._wrapped;
  };

  dont_chain = mori.list("list", "vector", "hash_map", "set", "sorted_set", "range", "iterate", "repeat", "repeatedly", "prim_seq", "identity", "constantly", "inc", "dec", "sum", "is_even", "is_odd", "comp", "juxt", "knit", "pipeline", "partial", "curry", "fnil", "js_to_clj", "clj_to_js", "equals", "hash");

  mori.each(dont_chain, function(name) {
    return m_[name] = mori[name];
  });

  end_of_chain = m_.list("is_list", "is_seq", "is_vector", "is_map", "is_set", "is_collection", "is_sequential", "is_associative", "is_counted", "is_indexed", "is_reduceable", "is_seqable", "is_reversible");

  mori.each(end_of_chain, function(name) {
    m_[name] = mori[name];
    return m_.prototype[name] = function() {
      return mori[name](this._wrapped);
    };
  });

  arg_first = m_.list("conj", "into", "assoc", "dissoc", "empty", "get", "get_in", "has_key", "find", "nth", "last", "assoc_in", "update_in", "count", "is_empty", "peek", "pop", "zipmap", "reverse", "each", "subvec", "keys", "vals", "disj", "union", "intersection", "difference", "is_subset", "is_superset", "first", "rest", "seq", "concat", "flatten", "into_array");

  result = function(obj) {
    if (this._chain) {
      return m_(obj).chain();
    } else {
      return obj;
    }
  };

  mori.each(arg_first, function(name) {
    m_[name] = mori[name];
    return m_.prototype[name] = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      args.unshift(this._wrapped);
      return result.call(this, mori[name].apply(mori, args));
    };
  });

  coll_last = m_.list("cons", "map", "mapcat", "filter", "remove", "reduce", "reduce_kv", "take", "take_while", "drop", "drop_while", "some", "every", "sort", "sort_by", "interpose", "interleave", "partition", "partition_by", "group_by");

  mori.each(coll_last, function(name) {
    m_[name] = mori[name];
    return m_.prototype[name] = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      args.push(this._wrapped);
      return result.call(this, mori[name].apply(mori, args));
    };
  });

}).call(this);
